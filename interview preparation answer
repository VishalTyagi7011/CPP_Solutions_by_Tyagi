======================================================================================================
--------------------------------------VARIABLE & DATA TYPES ------------------------------------------
======================================================================================================

 1.	Explain local vs. global variables.

 Ans:-   Local Variables:         (i).Defined within a function or a block and can only be accessed within that function or block. 
                                  (ii). They are created when the function is called and destroyed when the function exits.
         Global Variables:        (i).Defined outside of all functions and can be accessed by any function within the same file (or other files if declared with extern).
                                  (ii). They exist for the entire duration of the program.
------------------------------------------------------------------------------------------------------------------------
2. What are static_cast and dynamic_cast?

Ans :-   Static Cast  :            (i) Static_cast is a casting operator which is used to convert data type of a variable into another data type .
                                   (ii). Syntax : static_cast<datatype>(variable_name);
                                   (iii).  Example :- int main() 
                                           {
                                            for(int i=65;i<=90;i++)
                                            {
                                                cout<<static_cast<char>(i);
                                                cout<<endl;
                                            }
                                            return 0;
                                            }

         Dynamic Cast :             (i). Dynamic_cast is a operator which converts data from one to another(int to float, int to double) etc.
                                    (ii). There should be always a virtual function in base class to acheive dynamic cast. 
                                    (iii). There should be polymorphic base class and Dynamic_cast works on RTTI(Run time type information);
                                     (iv)             class Base {
                                                      public:
                                                          virtual void print() {
                                                              cout << "base class function" << endl;
                                                          }
                                                      };
                                                      
                                                      class Derived : public Base {
                                                      public:
                                                          int a = 6;
                                                          
                                                          void printff() {
                                                              cout << "derived class function" << endl;
                                                          }
                                                      };
                                                      
                                                      int main() {
                                                          Base *baseptr = new Derived(); // Create an instance of  Derived
                                                          Derived *derptr = dynamic_cast<Derived*>(baseptr); //Safe downcast
                                                      
                                                          if (derptr) { // Check if the cast was successful
                                                              derptr->print();    // Call the base class function
                                                              derptr->printff();  // Call the derived class  function
                                                          } else {
                                                              cout << "Cast failed!" << endl; // Handle unsuccessful cast
                                                          }
                                                      
                                                          delete baseptr; // Clean up
                                                          return 0;
                                                      }
                                                      

                                                   int main() {
                                                    Base *baseptr = new Derived(); // Create an instance of Derived
                                                   Derived *derptr = dynamic_cast<Derived*>(baseptr); // Safe downcast

                                                    if (derptr) { // Check if the cast was successful
                                                    derptr->print();    // Call the base class function
                                                    derptr->printff();  // Call the derived class function
                                                    } else {
                                                   cout << "Cast failed!" << endl; // Handle unsuccessful cast
                                                   }

                                                   delete baseptr; // Clean up
                                                      return 0;
                                                    }

-----------------------------------------------------------------------------------
3. What are the differences between stack and heap memory allocation in terms of variables?

Ans :- STACK :- 
                 (i). Memory is managed automatically.
                 (ii).Variables are created when a function is called and destroyed when the function returns.
                 (iii)..Generally has a smaller size limit (usually in the range of a few megabytes).
                 (iv).Faster access because of its LIFO structure and locality in memory.
       QUEUE :-
                  (i).Memory is managed manually by the programmer using new and delete.
                  (ii).Variables exist until they are explicitly deleted.
                  (iii).Typically larger and can grow as needed, limited mainly by system memory.
                   (iv).Slower access due to the overhead of dynamic memory management.

---------------------------------------------------------------------------------------
4.What happens if you try to use a variable before it is initialized?

Ans :- unpredicatable behaviour, value of variable will be garbage. expample:
#include <iostream>
using namespace std;

int main()
{
    int arr[5]; // Uninitialized array
    for (int i = 0; i < 5; ++i) {
        cout << arr[i]; // Undefined behavior: elements may hold garbage values
    }
    return 0;
}
--------------------------------------------------------------------------------------
5. What are the different storage classes in C++?

Ans :- (i)    Auto
       (ii).  Static
       (iii). Register
       (iv)   Extern



======================================================================================================================================
-------------------------------------------------OPERATORS---------------------------------------------------------------------------
======================================================================================================================================

1.	Explain the difference between == and = in C++.
Ans : (i). "==" is comparisonal operator and "=" is assignment operator.
      (ii). "==" compares two variable i.e they are equal or not. eg. (4==5) return 0.
      (iii) "=" assigns value to a variable. eg int a=5;

------------------------------------------------------------------------
2.How do comparison operators behave when applied to floating-point numbers? Can you give an example of potential pitfalls?
  Ans :-
 double a = (0.3 * 3) + 0.1;
	double b = 1;
	compare (a==b) // not equal.

 getting correct answer by fixing:
  if (abs(a - b) < 1e-9) {
        cout << "The numbers are equal "
             << endl;

----------------------------------------------------------------------------------------
3. Explain short-circuit evaluation in the context of logical operators
Ans :- example:
 (i). if(a>b && b>c&& c>d) :- if (a>b) is false, then remaining part(&& b>c&& c>d) of this condition  will not check and answer will be false.
 (ii). if(a>b || b>c|| c>d) :- if (a>b) is true, then remaining part(&& b>c&& c>d) of this condition  will not check and answer will be true.

--------------------------------------------------------------------------------------------
4.	How would you swap two variables using assignment operators without a temporary variable?
Ans . int main() {
   int a=5, b=10;
   a=a^b;
   b=a^b;
   a=a^b;
   
  cout<<"a is :"<<a<<endl<<"b is :"<<b;

    return 0;
}
-----------------------------------------------------------------------------------------
5. How would you use bitwise operators to check if a number is even or odd?

Ans . if (number & 1==1) , it is odd, otherwise(number & 1==0) will be even.

----------------------------------------------------------------------------------------
6. What is a ternary operator, and how does it work in C++?

Ans :- (i).Ternary operator is the shortest form of conditional statement . 
       (ii).it syntax is : datatype variable=(condition)?"True statement":"false statatement";
       (iii).int main() {
            string  result =5>2?"yes":"no";
            cout<<result;
            return 0;
             }

------------------------------------------------------------------------------------------
7.	Explain the fall-through behavior of the switch statement with an example.

Ans :- If there is 'no' break keyword used in statement which is true, then it will execute  other statement also.
       Example:
#include <stdio.h>

int main() {
    int day = 3;

    switch (day) {
        case 1:
            printf("Monday\n");
            // No break, will fall through to case 2
        case 2:
            printf("Tuesday\n");
            // No break, will fall through to case 3
        case 3:
            printf("Wednesday\n");
            // No break, will fall through to case 4
        case 4:
            printf("Thursday\n");
            break; // Breaks out of the switch
        case 5:
            printf("Friday\n");
            break; // This will not be executed
        default:
            printf("Invalid day\n");
    }

    return 0;
}
-----------------------------------------------------------------------------------------
8.	Discuss a scenario where using a ternary operator would be preferred over if-else for conciseness. Provide an example.

Ans. (i) The ternary operator is often preferred over if-else statements when you want to assign a value based on a simple condition.
    (ii).The ternary operator reduces the amount of code you need to write.



================================================================================================
------------------------------------FUNCTIONS--------------------------------------------------
================================================================================================
1.	What is an inline function, and how does it differ from a regular function?
Ans:-
Inline function is a function which is expanded in line when it is called.When the inline function is called whole code
of the inline function gets inserted or substituted at the point of the inline function call.Remember, inlining is only
a request to the compiler, not a command. The compiler can ignore the request for inlining. 
BENEFIT :- Faster execution
DISADVANTAGE :-more binary size, cannot use for recursive(result will be infinite loop)
Example:
inline int square(int x) {
    return x * x;
}

int main() {
    int result = square(5); // Compiler may replace this with `result = 5 * 5;`
}
----------------------------------------------------------------------------------------------------------
2. Under what circumstances might the compiler ignore the inline request?
Ans:- 
(i) Recursive function
(ii) Function with pointer parameter .eg.func(int *ram)
(iii) function complex

------------------------------------------------------------------------------------------------
3.	How would you design an inline function for calculating the area of a rectangle?
Ans:-
#include <iostream>

// Inline function to calculate the area of a rectangle
inline double areaOfRectangle(double length, double width) {
    return length * width;
}

int main() {
    double length = 5.0;
    double width = 3.0;
    
    double area = areaOfRectangle(length, width);
    std::cout << "Area of the rectangle: " << area << std::endl;

    return 0;
}


================================================================================================
--------------------------------------ARRAY-----------------------------------------------------
================================================================================================









